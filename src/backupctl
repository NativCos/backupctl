#!/usr/bin/env python3
import argparse
import json
import os
import sys
import subprocess


class Config:
    DEFAULT_CONFIG_FILE_FS_PATH = "/usr/local/etc/backupctl/conf.json"
    DEFAULT_CONFIG_EXCLUDE_FILE = "/usr/local/etc/backupctl/excludefile"

    PASSPHRASE = None
    SSH_PATH_TO_KEY = None
    SSH_PATH_TO_REPO = None

    @staticmethod
    def read_from_file(fs_path_to_config: str):
        config = Config()
        if not os.path.exists(fs_path_to_config):
            raise ValueError(f"Config file {fs_path_to_config} not exists")
        with open(fs_path_to_config, 'tr') as fp:
            json_config = json.load(fp)
        if 'passphrase' in json_config:
            config.PASSPHRASE = json_config['passphrase']
        if 'ssh_path_to_key' in json_config:
            config.SSH_PATH_TO_KEY = json_config['ssh_path_to_key']
        if 'ssh_path_to_repo' in json_config:
            config.SSH_PATH_TO_REPO = json_config['ssh_path_to_repo']
        config.check_correctness_config()
        return config

    def make_borg_variables(self):
        return f"BORG_RSH=\"ssh -i {self.SSH_PATH_TO_KEY} -o ServerAliveInterval=10 -o ServerAliveCountMax=60\"" + \
               f" BORG_REPO={self.SSH_PATH_TO_REPO}" + \
               f" BORG_PASSPHRASE={self.PASSPHRASE}"

    def check_correctness_config(self):
        if self.PASSPHRASE is None or not isinstance(self.PASSPHRASE, str) or len(self.PASSPHRASE) == 0:
            raise Exception("Config PASSPHRASE is invalid")
        if self.SSH_PATH_TO_KEY is None or not isinstance(self.SSH_PATH_TO_KEY, str):
            raise Exception("Config SSH_PATH_TO_KEY is invalid")
        if self.SSH_PATH_TO_REPO is None or not isinstance(self.SSH_PATH_TO_REPO, str):
            raise Exception("Config SSH_PATH_TO_REPO is invalid")
        if not os.path.exists(self.DEFAULT_CONFIG_EXCLUDE_FILE):
            raise Exception('CONFIG_EXCLUDE_FILE not exist')


class BackupCTL:
    config = None

    def __init__(self, config):
        self.config = config

    def init(self):
        """Borg init repo"""
        subprocess.run(
            self.config.make_borg_variables() + \
            ' borg init --encryption=repokey ::',
            shell=True, stderr=sys.stderr, stdout=sys.stdout)

    def backup(self, path_of_archiving='/'):
        """Make snapshot"""
        if not os.path.exists(path_of_archiving):
            raise RuntimeError("path of archiving not exist")
        os.chdir(path_of_archiving)
        subprocess.run(
            self.config.make_borg_variables() + \
            f" borg create -v --stats --progress --exclude-from {self.config.DEFAULT_CONFIG_EXCLUDE_FILE} --compression lz4 ::$(hostname -s)_$(date -Iseconds) .",
            shell=True, stderr=sys.stderr, stdout=sys.stdout)

    def show_list(self):
        """Print backups names"""
        subprocess.run(
            self.config.make_borg_variables() + \
            " borg list ::",
            shell=True, stderr=sys.stderr, stdout=sys.stdout)

    def show_info(self, backupname):
        """Print borg info by backup name"""
        if backupname is None:
            backupname = ""
        subprocess.run(
            self.config.make_borg_variables() + \
            f" borg info ::{backupname}",
            shell=True, stderr=sys.stderr, stdout=sys.stdout)

    def prune(self):
        """Borg delete special useless snapshots"""
        subprocess.run(
            self.config.make_borg_variables() + \
            " borg prune -v --stats --keep-within=7d --keep-last=3 --glob-archives=\"$(hostname -s)*\" ${@:2}",
            shell=True, stderr=sys.stderr, stdout=sys.stdout)

    def mount_fuse_all_backups(self, mountpoint: str):
        """FUSE readonly mount all backup images !VIEW ONLY!"""
        if not os.path.exists(mountpoint):
            raise Exception('mountpoint not exist')
        if not os.path.isdir(mountpoint):
            raise Exception('mountpoint is not dir')
        subprocess.run(
            f"{self.config.make_borg_variables()} borg mount :: {mountpoint}",
            shell=True, stderr=sys.stderr, stdout=sys.stdout)

    def extract(self, backupname: str, path):
        """Extract archive by name to CURRENT DIRECTORY

        Currently, extract always writes into the current working directory (“.”),
        so make sure you cd to the right place before calling borg extract.
        """
        if path is None:
            path = ""
        subprocess.run(
            self.config.make_borg_variables() + \
            f" borg extract --list ::{backupname} {path}",
            shell=True, stderr=sys.stderr, stdout=sys.stdout)

    def export_borg_variables(self):
        """export vars for work with borg program"""
        return f"export {self.config.make_borg_variables()}"


parser = argparse.ArgumentParser(prog='backupctl', description='Backup to a remote location using Borg.')
parser.add_argument('--config', nargs='?', type=str, help='json config file path')
parser.add_argument('--export_borg_variables', action='store_true', help='export vars for work with borg program')

subparsers = parser.add_subparsers(title='commands', dest='subcommand')
parser_init = subparsers.add_parser('init', help='create a repository')
parser_backup = subparsers.add_parser('backup', help='make a backup of system')
parser_backup.add_argument('BTRFS_SNAPSHOT', default=argparse.SUPPRESS, type=str, help='for btrfs snapshots. alternative os root path.')
parser_list = subparsers.add_parser('list', help='show backups names list')
parser_info = subparsers.add_parser('info', help='show backup info by name')
parser_info.add_argument('BACKUPNAME', default=argparse.SUPPRESS, type=str)
parser_prune = subparsers.add_parser('prune', help='delete useless backups')
parser_mount = subparsers.add_parser('mount', help='FUSE readonly mount all backup images !VIEW ONLY!')
parser_mount.add_argument('MOUNTPOINT', type=str, help='where readonly mounting all backups')
parser_extract = subparsers.add_parser('extract', help='Extract archive by name to CURRENT DIRECTORY. so make sure you cd to the right')
parser_extract.add_argument('BACKUPNAME', type=str)
parser_extract.add_argument('PATH', default=argparse.SUPPRESS, type=str, help='paths to extract (What only to extract from backup); patterns are supported')

args = parser.parse_args()

if args.config is not None:
    config = Config.read_from_file(args.config)
else:
    config = Config.read_from_file(Config.DEFAULT_CONFIG_FILE_FS_PATH)
backupctl = BackupCTL(config)

if args.export_borg_variables:
    print(backupctl.export_borg_variables())

match args.subcommand:
    case 'init':
        backupctl.init()
    case 'backup':
        if args.BTRFS_SNAPSHOT is not None:
            backupctl.backup(args.BTRFS_SNAPSHOT)
        else:
            backupctl.backup()
    case 'list':
        backupctl.show_list()
    case 'info':
        if args.BACKUPNAME is not None:
            backupctl.show_info(args.BACKUPNAME)
        else:
            backupctl.show_info(None)
    case 'prune':
        backupctl.prune()
    case 'mount':
        backupctl.mount_fuse_all_backups(args.MOUNTPOINT)
    case 'extract':
        print("Extract archive by name to CURRENT DIRECTORY. so make sure you cd to the right.")
        answer = input("Continue? [N/y]")
        if answer in ('y', 'Y', 'Yes'):
            if args.PATH is not None:
                backupctl.extract(args.BACKUPNAME, args.PATH)
            else:
                backupctl.extract(args.BACKUPNAME, None)
        else:
            print("interrupt.")
            exit()
